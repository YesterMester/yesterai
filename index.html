<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AI Chat â€” Puter Robust Fix</title>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    body{font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:linear-gradient(135deg,#667eea,#764ba2); min-height:100vh; padding:18px}
    .container{max-width:1100px;margin:0 auto;background:rgba(255,255,255,.96);border-radius:12px;box-shadow:0 20px 40px rgba(0,0,0,.12);overflow:hidden}
    .header{display:flex;justify-content:space-between;align-items:center;padding:16px 20px;background:linear-gradient(90deg,#4f46e5,#7c3aed);color:#fff}
    .header h1{font-size:1.25rem}
    .status{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.08)}
    .main{display:grid;grid-template-columns:320px 1fr;min-height:620px}
    .sidebar{padding:16px;border-right:1px solid #eef2ff;background:#fbfdff}
    .models h3{margin-bottom:8px}
    .model-option{background:#fff;border:1px solid #eef2ff;border-radius:8px;padding:10px;margin-bottom:8px;cursor:pointer}
    .model-option.active{background:linear-gradient(135deg,#4f46e5,#7c3aed);color:#fff;border-color:#4f46e5}
    .quick button{width:100%;margin-bottom:8px;padding:8px;border-radius:8px;border:1px solid #eef2ff;background:#fff;cursor:pointer}
    .api-block{margin-top:12px;background:#fff;padding:10px;border-radius:8px;border:1px solid #eef2ff}
    .api-block textarea{width:100%;height:56px;padding:8px;border-radius:6px;border:1px solid #e6eef8;resize:vertical}
    .api-block .row{display:flex;gap:8px;margin-top:8px}
    .api-block button{flex:1;padding:8px;border-radius:8px;border:none;cursor:pointer}
    .chatwrap{display:flex;flex-direction:column;height:100%}
    .messages{padding:18px;background:#fff;overflow:auto;flex:1}
    .message{margin-bottom:14px;padding:12px;border-radius:12px;max-width:84%;white-space:pre-wrap}
    .user{background:linear-gradient(135deg,#4f46e5,#7c3aed);color:#fff;margin-left:auto}
    .ai{background:#f1f5f9;color:#0f172a}
    .error{background:#fff6f6;color:#7f1d1d;border-left:4px solid #ef4444}
    .code-block{background:#0f1722;color:#e6eef8;padding:12px;border-radius:8px;margin-top:8px;font-family:monospace;position:relative;overflow:auto}
    .copy-btn{position:absolute;top:8px;right:8px;background:#4f46e5;color:#fff;border:none;padding:6px 8px;border-radius:6px;cursor:pointer}
    .input-area{padding:14px;border-top:1px solid #eef6ff;background:#fbfdff;display:flex;gap:10px;align-items:center}
    .message-input{flex:1;padding:12px 14px;border-radius:22px;border:2px solid #e6eef8;font-size:1rem;background:#fff}
    .send-btn{padding:10px 14px;border-radius:22px;background:linear-gradient(135deg,#4f46e5,#7c3aed);color:#fff;border:none;cursor:pointer;font-weight:600}
    .send-btn[disabled]{opacity:.6;cursor:not-allowed}
    @media(max-width:860px){.main{grid-template-columns:1fr}.sidebar{border-right:none;border-bottom:1px solid #eef6ff}}
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div>
        <h1>ðŸ¤– Puter AI Chat â€” Robust</h1>
        <div style="font-size:0.9rem;opacity:.9">Fixes "messages is not iterable" by trying many valid payload shapes</div>
      </div>
      <div class="status" id="statusBadge">Initializingâ€¦</div>
    </div>

    <div class="main">
      <div class="sidebar">
        <div class="models">
          <h3>Models</h3>
          <div class="model-option active" data-model="claude-opus-4.1">Claude Opus 4.1 ðŸ”¥</div>
          <div class="model-option" data-model="gpt-4-turbo">GPT-4 Turbo</div>
          <div class="model-option" data-model="gpt-4">GPT-4</div>
          <div class="model-option" data-model="gpt-3.5-turbo">GPT-3.5 Turbo</div>
          <div class="model-option" data-model="llama-3-70b">Llama 3 70B</div>
        </div>

        <div class="quick" style="margin-top:12px">
          <h3>Quick Prompts</h3>
          <button onclick="setPrompt('Create a Python function that')">Python</button>
          <button onclick="setPrompt('Build a React component that')">React</button>
          <button onclick="setPrompt('Write HTML/CSS to')">HTML/CSS</button>
        </div>

        <div class="api-block">
          <div style="font-weight:600">OpenAI Key (optional)</div>
          <textarea id="openaiKey" placeholder="sk-... (optional for OpenAI fallback)"></textarea>
          <div class="row" style="margin-top:8px">
            <button id="saveKeyBtn" style="background:#4f46e5;color:#fff">Save Key</button>
            <button id="clearKeyBtn" style="background:#fff;border:1px solid #eef2ff">Clear</button>
          </div>
          <div style="font-size:0.85rem;color:#475569;margin-top:8px">Client-side keys are for quick testing only. For production use a server proxy.</div>
        </div>
      </div>

      <div class="chatwrap">
        <div id="messages" class="messages">
          <div class="message ai">ðŸ‘‹ Welcome â€” select a model and ask a question.</div>
        </div>

        <div class="input-area">
          <input id="messageInput" class="message-input" placeholder="Ask for code, debugging, or anything..." onkeypress="handleKeyPress(event)" autocomplete="off" />
          <button id="sendBtn" class="send-btn" onclick="sendMessage()">Send ðŸš€</button>
        </div>
      </div>
    </div>
  </div>

  <script>
  /**************************************************************************
   Robust Puter client that explicitly fixes "messages is not iterable"
   by trying a set of valid payload shapes and gracefully falling back.
  ***************************************************************************/

  // ---------- Config & state ----------
  let currentModel = 'claude-opus-4.1';
  let puter = null;
  let isLoading = false;
  const statusBadge = document.getElementById('statusBadge');
  const OPENAI_STORAGE_KEY = 'chat_openai_key_v1';

  // ---------- UI helpers ----------
  function setStatus(text, bg) {
    statusBadge.textContent = text;
    statusBadge.style.background = bg || 'transparent';
  }

  function addMessage(role, text, isError = false) {
    const container = document.getElementById('messages');
    const el = document.createElement('div');
    el.className = 'message ' + (role === 'user' ? 'user' : 'ai') + (isError ? ' error' : '');
    // detect code fences and format
    if (typeof text !== 'string') text = safeStringify(text, 2000);
    const formatted = formatMessage(text);
    el.innerHTML = formatted;
    // attach copy to code blocks
    el.querySelectorAll('.code-block').forEach(block => {
      const btn = document.createElement('button');
      btn.className = 'copy-btn';
      btn.textContent = 'Copy';
      btn.onclick = () => {
        const codeEl = block.querySelector('code');
        if (!codeEl) return;
        navigator.clipboard.writeText(codeEl.textContent).then(() => {
          const prev = btn.textContent;
          btn.textContent = 'Copied!';
          setTimeout(() => btn.textContent = prev, 1200);
        });
      };
      block.appendChild(btn);
    });
    container.appendChild(el);
    container.scrollTop = container.scrollHeight;
    return el;
  }

  function formatMessage(text) {
    // preserve code fences, convert to code-block divs
    // first escape HTML for non-code parts; we'll rebuild
    // split by code fences
    const parts = text.split(/```/g);
    let out = '';
    for (let i = 0; i < parts.length; i++) {
      if (i % 2 === 0) {
        // normal text - escape HTML
        out += escapeHtml(parts[i]).replace(/\n/g, '<br>');
      } else {
        // code block - keep as pre/code
        // parts[i] may start with language id
        const firstLineIdx = parts[i].indexOf('\n');
        let lang = '';
        let code = parts[i];
        if (firstLineIdx !== -1) {
          const firstLine = parts[i].slice(0, firstLineIdx).trim();
          // if firstLine is a language token like 'js' or 'python', strip it
          if (/^[a-z0-9\-+]+$/i.test(firstLine)) {
            lang = firstLine;
            code = parts[i].slice(firstLineIdx + 1);
          }
        }
        out += `<div class="code-block"><pre><code>${escapeHtml(code)}</code></pre></div>`;
      }
    }
    // inline code `x`
    out = out.replace(/`([^`]+)`/g, '<code style="background:#eef2ff;padding:2px 6px;border-radius:4px;">$1</code>');
    return out;
  }

  function escapeHtml(s) {
    const d = document.createElement('div');
    d.textContent = s;
    return d.innerHTML;
  }

  // ---------- Safe stringify ----------
  function getCircularReplacer() {
    const seen = new WeakSet();
    return (k, v) => {
      if (typeof v === 'object' && v !== null) {
        if (seen.has(v)) return '[Circular]';
        seen.add(v);
      }
      return v;
    };
  }
  function safeStringify(obj, maxLen = 3000) {
    try {
      return JSON.stringify(obj, getCircularReplacer(), 2).slice(0, maxLen);
    } catch (e) {
      try { return String(obj).slice(0, maxLen); } catch (e2) { return '[unserializable]'; }
    }
  }

  // ---------- Response extractor ----------
  function extractTextFromResponse(resp) {
    if (resp == null) return '';
    if (typeof resp === 'string') return resp;
    // Common places to look
    const tryPaths = [
      ['choices',0,'message','content'],
      ['choices',0,'message','content',0,'text'],
      ['choices',0,'text'],
      ['output_text'],
      ['result','content'],
      ['result','response','content',0,'text'],
      ['content'],
      ['message','content'],
      ['data',0,'text'],
      ['outputs',0,'content',0,'text'],
      ['output',0,'content',0,'text'],
      ['response','text'],
      ['answer'],
      ['body','text'],
      ['text'],
      ['response']
    ];
    const dig = (o, path) => {
      try {
        for (const k of path) {
          if (o == null) return undefined;
          o = o[k];
        }
        return o;
      } catch (e) { return undefined; }
    };
    for (const p of tryPaths) {
      const v = dig(resp, p);
      if (v == null) continue;
      if (typeof v === 'string' && v.trim()) return v;
      if (Array.isArray(v)) {
        const j = v.map(x => typeof x === 'string' ? x : (x?.text || safeStringify(x,1000))).join('\n');
        if (j.trim()) return j;
      }
    }

    // outputs array case
    if (Array.isArray(resp.outputs)) {
      const parts = [];
      for (const o of resp.outputs) {
        if (!o) continue;
        if (typeof o === 'string') parts.push(o);
        else if (o.text) parts.push(o.text);
        else if (o.content) {
          if (Array.isArray(o.content)) {
            for (const c of o.content) {
              if (typeof c === 'string') parts.push(c);
              else if (c.text) parts.push(c.text);
              else parts.push(safeStringify(c,1000));
            }
          } else parts.push(safeStringify(o.content,1000));
        } else parts.push(safeStringify(o,1000));
      }
      if (parts.length) return parts.join('\n\n');
    }

    // shallow find strings
    const strings = [];
    (function hunt(o, depth=0) {
      if (!o || typeof o !== 'object' || depth > 4) return;
      for (const k of Object.keys(o)) {
        try {
          const v = o[k];
          if (typeof v === 'string' && v.trim()) strings.push(v);
          else if (typeof v === 'object') hunt(v, depth+1);
        } catch (e) {}
        if (strings.length >= 6) return;
      }
    })(resp);

    if (strings.length) return strings.join('\n\n');
    return safeStringify(resp, 3000);
  }

  // ---------- Dynamic load Puter script (try multiple urls) ----------
  function loadScript(url, timeout = 4000) {
    return new Promise((resolve, reject) => {
      const s = document.createElement('script');
      s.src = url;
      s.async = true;
      let done = false;
      s.onload = () => { if (!done) { done = true; resolve(true); } };
      s.onerror = () => { if (!done) { done = true; reject(new Error('Failed to load ' + url)); } };
      document.head.appendChild(s);
      if (timeout) setTimeout(() => { if (!done) { done = true; reject(new Error('Timeout ' + url)); } }, timeout);
    });
  }

  async function tryLoadPuter() {
    const urls = [
      'https://js.puter.com/v2/',
      'https://js.puter.com/v2/puter.min.js',
      'https://cdnjs.cloudflare.com/ajax/libs/puter/2.0.0/puter.min.js'
    ];
    for (const u of urls) {
      try {
        await loadScript(u, 3000);
        // give script a moment to initialize
        await new Promise(r => setTimeout(r, 250));
        if (window.puter) return true;
      } catch (e) {
        // continue trying others
        console.warn('Puter load failed for', u, e);
      }
    }
    return false;
  }

  async function initPuter() {
    setStatus('Loading Puter...');
    try {
      const ok = await tryLoadPuter();
      if (!ok) {
        puter = null;
        setStatus('Puter not loaded â€” fallback ready', 'linear-gradient(90deg,#f97316,#fb923c)');
        return;
      }
      // initialize if lib exposes init()
      if (window.puter && typeof window.puter.init === 'function') {
        try {
          puter = await window.puter.init().catch(e => { console.warn('puter.init failed', e); return window.puter || null; });
        } catch (e) { puter = window.puter || null; }
      } else {
        puter = window.puter || null;
      }
      if (puter) setStatus('Puter ready', 'linear-gradient(90deg,#10b981,#06b6d4)');
      else setStatus('Puter present but not initialized', 'linear-gradient(90deg,#f97316,#fb923c)');
    } catch (e) {
      console.warn('initPuter error', e);
      puter = null;
      setStatus('Puter failed to load', 'linear-gradient(90deg,#ef4444,#f97316)');
    }
  }

  // ---------- Try multiple payload shapes to avoid "messages is not iterable" ----------
  async function tryPuterChat(message, model) {
    if (!puter) throw new Error('Puter not available');
    const attempts = [];

    // Attempt functions that return a promise which resolves to the response
    attempts.push(async () => {
      // Common modern shape: messages:[{role, content:[{type:'text', text}]}]
      return await puter.ai.chat({ model, messages: [{ role: 'user', content: [{ type: 'text', text: message }] }] });
    });

    attempts.push(async () => {
      // messages with content as string
      return await puter.ai.chat({ model, messages: [{ role: 'user', content: message }] });
    });

    attempts.push(async () => {
      // messages using 'text' property
      return await puter.ai.chat({ model, messages: [{ role: 'user', text: message }] });
    });

    attempts.push(async () => {
      // older SDKs: chat({model, input: message})
      if (typeof puter.ai.chat === 'function') return await puter.ai.chat({ model, input: message });
      if (typeof puter.chat === 'function') return await puter.chat({ model, input: message });
    });

    attempts.push(async () => {
      // some SDKs accept a single string
      if (typeof puter.ai.chat === 'function') return await puter.ai.chat(message);
      if (typeof puter.chat === 'function') return await puter.chat(message);
    });

    attempts.push(async () => {
      // try puter.generate / createCompletion shapes
      if (typeof puter.ai.generate === 'function') return await puter.ai.generate({ model, prompt: message });
      if (typeof puter.generate === 'function') return await puter.generate({ model, prompt: message });
    });

    attempts.push(async () => {
      // try different key names - some builds use 'messages' as object with "items" etc
      return await puter.ai.chat({ model, messages: { items: [{ role: 'user', content: message }] } });
    });

    // iterate attempts until one succeeds (no thrown exception and returns non-empty)
    let lastError = null;
    for (const attempt of attempts) {
      try {
        const resp = await attempt();
        // if response looks like an error object with success=false, treat as error
        if (resp && resp.success === false && resp.error) {
          lastError = new Error('provider error: ' + (typeof resp.error === 'string' ? resp.error : safeStringify(resp.error)));
          continue;
        }
        // If resp is undefined/null, skip
        if (resp == null) { lastError = new Error('empty response'); continue; }
        // Return the response (caller will extract text)
        return resp;
      } catch (err) {
        // Specific handling: if message about "messages is not iterable" appears, try next shape
        lastError = err;
        // continue to next attempt
      }
    }
    // If none worked, throw last error for debugging
    throw lastError || new Error('no valid puter call succeeded');
  }

  // ---------- OpenAI client fallback (client-side) ----------
  const openaiModelMap = { 'gpt-4': 'gpt-4', 'gpt-4-turbo': 'gpt-4o', 'gpt-3.5-turbo': 'gpt-3.5-turbo' };
  async function callOpenAI(message, model) {
    const key = (document.getElementById('openaiKey').value || localStorage.getItem(OPENAI_STORAGE_KEY) || '').trim();
    if (!key) throw new Error('No OpenAI key provided');
    const useModel = openaiModelMap[model] || 'gpt-3.5-turbo';
    const payload = { model: useModel, messages: [{ role: 'user', content: message }], max_tokens: 1200, temperature: 0.2 };
    const res = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: { 'Authorization': 'Bearer ' + key, 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    if (!res.ok) {
      const txt = await res.text().catch(()=>res.statusText);
      throw new Error('OpenAI error: ' + res.status + ' ' + txt);
    }
    const data = await res.json();
    return extractTextFromResponse(data);
  }

  // ---------- Demo fallback ----------
  async function simulateResponse(message, model) {
    await new Promise(r => setTimeout(r, 600 + Math.random()*900));
    const lower = message.toLowerCase();
    if (lower.includes('python') || lower.includes('function')) {
      return `\`\`\`python\ndef example(x):\n    return x*2\n\nprint(example(5))\n\`\`\``;
    }
    if (lower.includes('react') || lower.includes('component')) {
      return `\`\`\`jsx\nexport default function Example(){\n  return <div>Hello from ${model}</div>\n}\n\`\`\``;
    }
    if (lower.includes('html') || lower.includes('css')) {
      return `\`\`\`html\n<div class="card">Hello from ${model}</div>\n\`\`\``;
    }
    return `I'm ${model} (demo). Ask me to generate code, debug, or explain something.`;
  }

  // ---------- Main send flow ----------
  async function sendMessage() {
    const inputEl = document.getElementById('messageInput');
    const text = (inputEl.value || '').trim();
    if (!text || isLoading) return;
    addMessage('user', text);
    inputEl.value = '';
    isLoading = true;
    const sendBtn = document.getElementById('sendBtn');
    sendBtn.disabled = true;
    sendBtn.textContent = 'Thinking...';
    const loadingEl = addMessage('ai', 'â€¦');

    try {
      let aiRaw = null;
      // prefer Puter when available
      if (puter) {
        setStatus('Using Puter.ai', 'linear-gradient(90deg,#10b981,#06b6d4)');
        try {
          aiRaw = await tryPuterChat(text, currentModel);
        } catch (e) {
          // if Puter call fails, continue to try OpenAI/demo
          console.warn('Puter call failed', e);
          aiRaw = { error: 'Puter call failed: ' + safeStringify(e) };
        }
        // If aiRaw is an error-like shape with success:false, preserve it
        if (aiRaw && aiRaw.error && !aiRaw.output_text && !aiRaw.choices) {
          // we'll show this error but also try OpenAI fallback below
        } else {
          // we have a response from puter â€” extract and display it
          const textOut = extractTextFromResponse(aiRaw);
          removeMessage(loadingEl);
          addMessage('ai', textOut);
          setStatus('Puter result', 'linear-gradient(90deg,#06b6d4,#60a5fa)');
          return;
        }
      }

      // fallback: OpenAI if key provided
      const haveKey = (document.getElementById('openaiKey').value || localStorage.getItem(OPENAI_STORAGE_KEY) || '').trim();
      if (haveKey) {
        try {
          setStatus('Using OpenAI key', 'linear-gradient(90deg,#06b6d4,#60a5fa)');
          const openaiText = await callOpenAI(text, currentModel);
          removeMessage(loadingEl);
          addMessage('ai', openaiText);
          return;
        } catch (e) {
          console.warn('OpenAI fallback failed', e);
          // continue to demo
        }
      }

      // final fallback: simulated
      const sim = await simulateResponse(text, currentModel);
      removeMessage(loadingEl);
      addMessage('ai', sim);
      setStatus('Demo response', 'linear-gradient(90deg,#f97316,#fb923c)');
    } catch (err) {
      console.error('sendMessage unexpected error', err);
      removeMessage(loadingEl);
      addMessage('ai', 'Error: ' + safeStringify(err, 2000), true);
      setStatus('Error occurred', 'linear-gradient(90deg,#ef4444,#f97316)');
    } finally {
      isLoading = false;
      sendBtn.disabled = false;
      sendBtn.textContent = 'Send ðŸš€';
      document.getElementById('messageInput').focus();
    }
  }

  // ---------- helpers: remove element ----------
  function removeMessage(el) {
    if (el && el.parentNode) el.parentNode.removeChild(el);
  }

  // ---------- init & wiring ----------
  function initializeUI() {
    document.querySelectorAll('.model-option').forEach(opt => {
      opt.addEventListener('click', () => {
        document.querySelectorAll('.model-option').forEach(o => o.classList.remove('active'));
        opt.classList.add('active');
        currentModel = opt.dataset.model;
        addMessage('ai', `Switched to ${opt.textContent.trim()}.`);
      });
    });

    document.getElementById('sendBtn').addEventListener('click', sendMessage);
    document.getElementById('messageInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    document.getElementById('saveKeyBtn').addEventListener('click', () => {
      const val = document.getElementById('openaiKey').value.trim();
      if (!val) { alert('Paste an OpenAI key to save'); return; }
      localStorage.setItem(OPENAI_STORAGE_KEY, val);
      setStatus('OpenAI key saved', 'linear-gradient(90deg,#06b6d4,#60a5fa)');
      alert('Key saved to localStorage (testing only). Use a server proxy for production.');
    });
    document.getElementById('clearKeyBtn').addEventListener('click', () => {
      localStorage.removeItem(OPENAI_STORAGE_KEY);
      document.getElementById('openaiKey').value = '';
      setStatus('OpenAI key cleared', 'linear-gradient(90deg,#f97316,#fb923c)');
    });

    // load saved key into textarea if present
    const saved = localStorage.getItem(OPENAI_STORAGE_KEY);
    if (saved) document.getElementById('openaiKey').value = saved;
  }

  // ---------- boot sequence ----------
  (async function boot() {
    initializeUI();
    setStatus('Loading Puter (attempting multiple CDNs)...');
    await initPuter();
    if (!puter) {
      setStatus('No Puter loaded â€” using OpenAI/demo fallback', 'linear-gradient(90deg,#f97316,#fb923c)');
    }
    const input = document.getElementById('messageInput');
    if (input) input.focus();
  })();

  // expose some things to console for debugging
  window._puter = () => puter;
  window.sendMessage = sendMessage;
  window.tryPuterChat = tryPuterChat;
  window.extractTextFromResponse = extractTextFromResponse;

  </script>
</body>
</html>